#version 330 core

uniform sampler2D interior_tex0;
uniform sampler2D interior_tex1;

uniform sampler2D tex_top;
uniform sampler2D tex_down;
uniform sampler2D tex_left;
uniform sampler2D tex_right;
uniform sampler2D tex_back;

uniform vec3 cam_pos;

uniform float side_size;

uniform vec4 ceilings[10];
uniform vec4 side_walls[10];
uniform vec4 back_walls[10];
uniform float ceiling_count;
uniform float side_wall_count;
uniform float back_wall_count;

//世界坐标系下 模型中心点 和local xyz单位向量
uniform vec3 model_center_pos;
uniform vec3 model_local_x_dir;
uniform vec3 model_local_y_dir;
uniform vec3 model_local_z_dir;

in vec3 v_vertex;

out vec4 color;

bool is_equal(float a, float b)
{
    return abs(a-b) < 0.01;
}

vec2 get_pos_range(float current_index, float wall_count, float min_val, float max_val)
{   
    float _step = (max_val-min_val)/(wall_count-1);
    return vec2(min_val+current_index*_step, min_val+ min(current_index+1, wall_count-1)*_step); 
}

void main() {
    vec3 view_dir = normalize(v_vertex-cam_pos);
    color = vec4(0.0, 0.0, 0.0, 1.0);
    vec2 world_pos_to_uv_offset = vec2(side_size/2.0, side_size/2.0);

    // 整个cube x,y,z尺寸范围
    vec3 min_x_pos = model_center_pos - model_local_x_dir * side_size / 2.0;
    vec3 max_x_pos = model_center_pos + model_local_x_dir * side_size / 2.0;
    vec3 min_y_pos = model_center_pos - model_local_y_dir * side_size / 2.0;
    vec3 max_y_pos = model_center_pos + model_local_y_dir * side_size / 2.0;
    vec3 min_z_pos = model_center_pos - model_local_z_dir * side_size / 2.0;
    vec3 max_z_pos = model_center_pos + model_local_z_dir * side_size / 2.0;

    vec3 N = vec3(0.0, 0.0, 0.0);
    float D = 0.0;
    float NdotV = 0.0;
    vec3 closest_point = vec3(0.0, 0.0, -10000);
    int point_type = -1; //0:天花板、地板 1:左右墙 2:前后墙
    vec2 x_pos_range = vec2(0.0, 0.0);
    vec2 y_pos_range = vec2(0.0, 0.0);
    vec2 z_pos_range = vec2(0.0, 0.0);

    for(int k=0; k<back_wall_count; ++k)
    {   
        for(int i=0; i<side_wall_count; ++i)
        {
            for(int j=0; j<ceiling_count; ++j)
            {   
                //当前cell的x,y,z范围
                vec2 _x_pos_range = get_pos_range(i, side_wall_count, min_x_pos.x, max_x_pos.x);
                vec2 _y_pos_range = get_pos_range(j, ceiling_count, min_y_pos.y, max_y_pos.y);
                vec2 _z_pos_range = get_pos_range(k, back_wall_count, min_z_pos.z, max_z_pos.z);
                vec3 _N;
                float _D;
                float _NdotV;

                //天花板 地板
                _N = ceilings[j].xyz;
                _D = ceilings[j].w;
                _NdotV = dot(_N, view_dir);
                if(!is_equal(_NdotV, 0.0))
                {
                    float t = -(dot(_N, cam_pos)+_D) / _NdotV;
                    vec3 point = cam_pos + t * view_dir;
                    if( point.z > _z_pos_range.x && point.z < _z_pos_range.y && point.x > _x_pos_range.x && point.x < _x_pos_range.y)
                    {
                        if(length(point-cam_pos) < length(closest_point-cam_pos))
                        {
                            closest_point = point;
                            x_pos_range = _x_pos_range;
                            z_pos_range = _z_pos_range;
                            N = _N;
                            D = _D;
                            NdotV = _NdotV;
                            point_type = 0;
                        }
                    }
                }
                
                //左右墙
                _N = side_walls[i].xyz;
                _D = side_walls[i].w;
                _NdotV = dot(_N, view_dir);
                if(!is_equal(_NdotV, 0.0))
                {
                    float t = -(dot(_N, cam_pos)+_D) / _NdotV;
                    vec3 point = cam_pos + t * view_dir;
                    if(point.z > _z_pos_range.x && point.z < _z_pos_range.y && point.y > _y_pos_range.x && point.y < _y_pos_range.y)
                    {
                        if(length(point-cam_pos) < length(closest_point-cam_pos))
                        {
                            closest_point = point;
                            z_pos_range = _z_pos_range;
                            y_pos_range = _y_pos_range;
                            N = _N;
                            D = _D;
                            NdotV = _NdotV;
                            point_type = 1;
                        }
                    }
                }
                //前后墙
                _N = back_walls[k].xyz;
                _D = back_walls[k].w;
                _NdotV = dot(_N, view_dir);
                if(!is_equal(_NdotV, 0.0))
                {
                    float t = -(dot(_N, cam_pos)+_D) / _NdotV;
                    vec3 point = cam_pos + t * view_dir;
                    if(_NdotV < 0.0)
                    { 
                        if(point.x > _x_pos_range.x && point.x < _x_pos_range.y && point.y > _y_pos_range.x && point.y < _y_pos_range.y)
                        {  
                            if(length(point-cam_pos) < length(closest_point-cam_pos))
                            {   
                                float u = fract((point.x-_x_pos_range.x) / (_x_pos_range.y-_x_pos_range.x));
                                float v = fract((_y_pos_range.y-point.y) / (_y_pos_range.y-_y_pos_range.x));
                                // D<0的平面当作正面
                                if(-dot(_N, _N*_D) > 0)
                                {
                                    if(((0.47 < u && u < 0.53) || (0.49 < v && v < 0.51 )) )
                                    {
                                        closest_point = point;
                                        x_pos_range = _x_pos_range;
                                        y_pos_range = _y_pos_range;
                                        N = _N;
                                        D = _D;
                                        NdotV = _NdotV;
                                        point_type = 2;
                                    }
                                }
                                else 
                                {
                                    closest_point = point;
                                    x_pos_range = _x_pos_range;
                                    y_pos_range = _y_pos_range;
                                    N = _N;
                                    D = _D;
                                    NdotV = _NdotV;
                                    point_type = 2;
                                }
                            }
                        }
                    }
                }           
            }
        }

                
    }
    
    //天花板 地板
    if (point_type == 0)
    {
        float u = fract((x_pos_range.y-closest_point.x) / (x_pos_range.y-x_pos_range.x));
        float v = fract((closest_point.z-z_pos_range.x) / (z_pos_range.y-z_pos_range.x));
        if(NdotV > 0.0)
        {
            color = texture(tex_top, vec2(v, 1.0-u));
        }
        else{
            color = texture(tex_down, vec2(v, u));
        }
    }
    //左右墙
    else if(point_type == 1)
    {
        float u = fract((z_pos_range.y-closest_point.z) / (z_pos_range.y-z_pos_range.x));
        float v = fract((y_pos_range.y-closest_point.y) / (y_pos_range.y-y_pos_range.x));
        if(NdotV > 0.0)
        {
            color = texture(tex_right, vec2(1.0-u, v));
        }
        else{
            color = texture(tex_left, vec2(u, v));
        }
    }
    //前后墙
    else if (point_type == 2)
    {   
        //前面的墙单独画十字
        if(-dot(N, N*D) > 0)
        {
            color = vec4(0.0, 0.0, 0.0, 1.0);
        }
        else
        {
            float u = fract((closest_point.x-x_pos_range.x) / (x_pos_range.y-x_pos_range.x));   
            float v = fract((y_pos_range.y-closest_point.y) / (y_pos_range.y-y_pos_range.x));
            color = texture(tex_back, vec2(u, v));
        }  
    }
    
}