#version 330 core

uniform vec3 cam_pos;

uniform sampler2D base_color;
uniform sampler2D normal_tex;
uniform sampler2D height_tex;

in vec3 v_vertex;
in vec2 v_uv;
in vec3 v_tbn_view_dir;
in vec3 v_tbn_light_dir;

out vec4 color;

void main() {

    float texture_size = 1024.0;
    float light_intensity = 2.5;
    vec3 view_dir = normalize(v_vertex-cam_pos);

    float depth;
    vec2 uv_offset = vec2(0.0);
    vec3 tex_color;
    vec3 normal;

    //for (int i=0; i<5; ++i)
    //{
    depth = texture(height_tex, v_uv + uv_offset).r * 255.0;
    uv_offset += vec2(depth / texture_size, depth / texture_size) * normalize(v_tbn_view_dir).xy;
    tex_color = texture(base_color, v_uv + uv_offset).xyz;
    normal = normalize(texture(normal_tex, v_uv + uv_offset).xyz);
    //}
    

    vec3 diffuse_color = max(dot(normalize(v_tbn_light_dir), normal), 0.0) * light_intensity * tex_color;
    color = vec4(diffuse_color, 1.0);
}

//  v2fConnector distanceVertex(a2vConnector a2v,    
//  uniform float4x4 modelViewProj,    
//  uniform float3 eyeCoord,    
//  uniform float3 lightCoord,    
//  uniform float invBumpDepth)  {      
//      v2fConnector v2f;      
//      // Project position into screen space      
//      // and pass through texture coordinate    
//      v2f.projCoord = mul(modelViewProj, float4 (a2v.objCoord, 1));    
//      v2f.texCoord = float3 (a2v.texCoord, 1);      
//      // Transform the eye vector into tangent space.    
//      // Adjust the slope in tangent space based on bump depth      
//      float3 eyeVec = eyeCoord - a2v.objCoord;    
//      float3 tanEyeVec;    
//      tanEyeVec.x = dot(a2v.objTangent, eyeVec);    
//      tanEyeVec.y = dot(a2v.objBinormal, eyeVec);    
//      tanEyeVec.z = -invBumpDepth * dot(a2v.objNormal, eyeVec);    
//      v2f.tanEyeVec = tanEyeVec;      
//      // Transform the light vector into tangent space.    
//      // We will use this later for tangent-space normal mapping      
//      float3 lightVec = lightCoord - a2v.objCoord;    
//      float3 tanLightVec;    
//      tanLightVec.x = dot(a2v.objTangent, lightVec);    
//      tanLightVec.y = dot(a2v.objBinormal, lightVec);    
//      tanLightVec.z = dot(a2v.objNormal, lightVec);    
//      v2f.tanLightVec = tanLightVec;      
//      return v2f;    
//      } 

// f2fConnector distanceFragment(
//     v2fConnector v2f,    
//     uniform sampler2D colorTex,    
//     uniform sampler2D normalTex,    
//     uniform sampler3D distanceTex,    
//     uniform float3 normalizationFactor)  
//     {    f2fConnector f2f;      
//     // Normalize the offset vector in texture space.     
//     // The normalization factor ensures we are normalized with respect    
//     // to a distance which is defined in terms of pixels.    
//     float3 offset = normalize(v2f.tanEyeVec);    
//     offset *= normalizationFactor;      
//     float3 texCoord = v2f.texCoord;      
//     // March a ray      
//     for (int i = 0; i < NUM_ITERATIONS; i++) 
//     {      
//         float distance = f1tex3D(distanceTex, texCoord);      
//         texCoord += distance * offset;    }      
//         // Compute derivatives of unperturbed texcoords.    
//         // This is because the offset texcoords will have discontinuities     
//         // which lead to incorrect filtering.    
//         float2 dx = ddx(v2f.texCoord.xy);    
//         float2 dy = ddy(v2f.texCoord.xy);      
//         // Do bump-mapped lighting in tangent space.    
//         // 'normalTex' stores tangent-space normals remapped      
//         // into the range [0, 1].    
//         float3 tanNormal = 2 * f3tex2D(normalTex, texCoord.xy, dx, dy) - 1;    
//         float3 tanLightVec = normalize(v2f.tanLightVec);    
//         float diffuse = dot(tanNormal, tanLightVec);      
//         // Multiply diffuse lighting by texture color      
//         f2f.COL.rgb = diffuse * f3tex2D(colorTex, texCoord.xy, dx, dy);    
//         f2f.COL.a = 1;      
//         return f2f;   
//     } 